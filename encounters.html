<head>
    <meta charset="utf-8">
    <title>Bard's Gate Random Encounter Generator</title>
    <link href="jquery-ui.min.css" rel="stylesheet">
    <link href="jquery-ui.theme.min.css" rel="stylesheet">
    <style>
    .ui-button {
    }
    .enc {
        margin-top:1em;
    }
    .top_button {
        font-size:xx-large !important;
        min-width:8em !important;
        margin:.2em .2em !important;
        padding:5 6;
    }
    .legal {
        font-size:x-small;
        margin-top:2em;
    }
    .stat_block {
        display:block;
        margin:15px;
    }
    .title {
        font-style:x-large;
    }
    .subtitle {
        font-style:italic;
        font-size:small;
    }
    </style>

</head>
<body>
<div id="main">
    <h1 class='title'>Welcome to the Bard's Gate Random Encounter Generator.</h1>
    <h2 class='subtitle'>May Tsathogga infest with boils any Non-GMs who click below. In other words, beware spoilers!</h2>
    <div id="button_list">
</div>
<div class="enc">

</div>
</div>
<div class='legal'>The Bard's Gate Random Encounter generator uses material from the 2016 commercial release of Bard's Gate by Frog God Games. The Bard's Gate Random Encounter generator operates under the terms and conditions of the Open Gaming License. Permission for use of product identity as expressly granted by Frog God Games for use in Bard's Gate Random Encounter generator and may not be reused for any other purpose without express written consent. Bard's Gate, Swords & Wizardry and the Frog God Games logo are all copyright Â© 2016 Frog God Games. All rights reserved.</div>

<script src="jquery.min.js"></script>
<script src="jquery-ui.min.js"></script>
<script src="encounters.js"></script>
<script>
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function roll(amount, type) {
    var count = 0;
    for (var i=0; i<amount; i++) {
        count += getRandomInt(1, type);
    }
    return count;
}

function table_roll(table) {
    var which = getRandomInt(0, table.length -1);
    return table[which];
}

function replace_markers(text) {
    var matches = text.match(/!d\[.*?]/gi);
    if (matches) {
        for (var i=0; i<matches.length; i++) {
            var split = matches[i].split('[')[1].split(/d/i);
            var dice_type = split[1];
            var minus = dice_type.indexOf('-');
            var plus = dice_type.indexOf('+');
            if (minus != -1)
                minus = parseInt(dice_type.substring(minus+1));
            else
                minus = 0;
            if (plus != -1) {
                plus = parseInt(dice_type.substring(plus+1));
            }
            else
                plus = 0;

            var count = roll(split[0], parseInt(dice_type));
            count += plus;
            count -= minus;
            text = text.replace(matches[i], count);
        }
    }
    matches = text.match(/!t\[.*?]/g);
    if (matches) {
        for (var i=0; i<matches.length; i++) {
            var table_name = matches[i].split('[')[1].split(']')[0];
            text = text.replace(matches[i], table_roll(t[table_name]));
        }
    }
    return text;
}

function select_item(entry) {
    if (entry.extra) {
        var choice = getRandomInt(1, entry.extra.total);
        // choice = 1; //greg remove, only here for testing
        for (var i=0; i<entry.extra.chances.length; i++) {
            if (choice >= entry.extra.chances[i].min && choice <= entry.extra.chances[i].max) {
                if (entry.extra.chances[i].append) {
                    var stats;
                    var text = entry.name +": ";
                    if (entry.stats) {
                        if (entry.extra.chances[i].stats)
                            stats = entry.stats.concat(entry.extra.chances[i].stats);
                        else
                            stats = entry.stats
                    } else {
                        stats = entry.extra.chances[i].stats;
                    }
                    if (entry.text) {
                        text = text+entry.text;
                    }
                    if (entry.extra.chances[i].text) {
                        if (entry.text)
                            text +=" ";
                        text = text+entry.extra.chances[i].text;
                    }
                    return [text, stats];
                }
                else {
                    var stats;
                    var text = "";
                    if (entry.extra.chances[i].stats)
                        stats = entry.extra.chances[i].stats;
                    else
                        stats = entry.stats;
                    if (entry.extra.chances[i].name)
                        text = entry.extra.chances[i].name+": ";
                    else
                        text = entry.name+": ";
                    return [text+entry.extra.chances[i].text, stats];
                }
            }
        }
    }

    return [entry.name+": "+entry.text, entry.stats];
}

function render_stat_blocks(block_list) {
    var text = "";
    for (var i=0; i<block_list.length; i++)
        text += "<DIV class=stat_block>"+stat_blocks[block_list[i]]+"</DIV>";
    return text;
}

function get_table_entry(table) {
    var debug = false; // force to use last entry in table for debugging purposes.
    var found = false;
    var which;
    //debug = true; // only for debugging, breaks normal usage. Do not commit with this uncommented.
    while (!found) {
        which = getRandomInt(0, table.items.length -1);
        if (debug == true) {
            console.log("forcing to use latest entry for debugging purposes. remove this!!!");
            which = table.items.length - 1;
        }
        if (table.items[which].sublist != undefined) {
            console.log("Sub table found");
            table = table.items[which].list; // now search the new sub-table
        } else {
            found = true;
        }
    }

    return table.items[which];
}
function generate_encounter() {
    var table = enc[$(this).attr('id')];
    var entry = get_table_entry(table);
    var item = select_item(entry);

    var text = replace_markers(item[0]);
    if (item[1]) {
        text += render_stat_blocks(item[1]);
    }
    $('.enc').html(text);
}
    
function onReady()
{
    var debug = false;
    // create enc.all list that includes all encounters

    var buttons = $('#button_list');
    /*for (var key in e) // add all encounters to an 'All' list
        enc.All.items.push(e[key]);*/
    for (var key in enc) {
        if (enc[key].hide != true)
        buttons.append('<button class="top_button" id="'+key+'">' + enc[key].name+'</button>');
    }
    $('.top_button').button().click(generate_encounter);
    //debug = true;
    if (debug == true) {
        for (var key in enc) {
            var table = enc[key].items;
            for (var i=0; i<table.length-1; i++) {
                if (table[i] == undefined)
                    console.log("Undefined entry at " +i + " in " + key);
            }
        }
        for (var eKey in e) {
            var found = false;
            //console.log("testing " + e[eKey].name);
            for (var encKey in enc) {
                if (found)
                    break;
                //console.log("against list " + encKey);
                //if (encKey != 'All') {
                    for (var j=0; j<enc[encKey].items.length && !found; j++) {
                        if (enc[encKey].items[j] == e[eKey]) {
                            found = true;
                        }
                    }
                //}
            }
            if (!found)
                console.log("Encounter " + eKey + " is not used in any lists. Fix this.");
        }
    }
};
$(document).ready(onReady);
</script>
</body>

